<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>rPPG Liveness Detection - Enterprise Demo</title>
    
    <!-- TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0"></script>
    
    <!-- MediaPipe Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 24px;
            box-shadow: 0 20px 60px rgba(0,0,0,.3);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 32px 40px;
        }
        
        .header h1 {
            font-size: 32px;
            margin-bottom: 8px;
            font-weight: 700;
        }
        
        .header p {
            opacity: .9;
            font-size: 14px;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1.4fr 1fr;
            gap: 30px;
            padding: 30px;
        }
        
        .video-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .video-container {
            position: relative;
            background: #000;
            border-radius: 16px;
            overflow: hidden;
            aspect-ratio: 4/3;
            border: 4px solid #e0e0e0;
            transition: all .3s;
        }
        
        .video-container.analyzing {
            border-color: #ffc107;
            box-shadow: 0 0 40px rgba(255,193,7,.4);
        }
        
        .video-container.verified {
            border-color: #4caf50;
            box-shadow: 0 0 40px rgba(76,175,80,.5);
        }
        
        .video-container.rejected {
            border-color: #f44336;
            box-shadow: 0 0 40px rgba(244,67,54,.5);
        }
        
        #webcam, #canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
        
        .status-badge {
            position: absolute;
            top: 16px;
            left: 16px;
            background: rgba(0,0,0,.85);
            backdrop-filter: blur(10px);
            padding: 10px 16px;
            border-radius: 8px;
            z-index: 10;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: .6; transform: scale(.95); }
        }
        
        .dot-idle { background: #9e9e9e; }
        .dot-analyzing { background: #ffc107; }
        .dot-verified { background: #4caf50; }
        .dot-rejected { background: #f44336; }
        
        .status-text {
            color: white;
            font-weight: 600;
            font-size: 13px;
        }
        
        .ppg-compact {
            position: absolute;
            bottom: 16px;
            left: 16px;
            right: 16px;
            background: rgba(0,0,0,.9);
            backdrop-filter: blur(10px);
            padding: 12px 16px;
            border-radius: 8px;
            z-index: 10;
            border: 2px solid rgba(76,175,80,.5);
        }
        
        .ppg-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            color: white;
            font-size: 12px;
        }
        
        .ppg-waveform {
            height: 50px;
            width: 100%;
        }
        
        .control-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }
        
        .btn {
            padding: 16px 24px;
            border: none;
            border-radius: 10px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all .2s;
        }
        
        .btn:disabled {
            opacity: .5;
            cursor: not-allowed;
        }
        
        .btn:not(:disabled):hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 16px rgba(0,0,0,.2);
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .btn-success {
            background: linear-gradient(135deg, #56ab2f 0%, #a8e063 100%);
            color: white;
        }
        
        .btn-danger {
            background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%);
            color: white;
        }
        
        .btn-full {
            grid-column: 1 / -1;
        }
        
        .method-selector {
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            border: 2px solid #2196f3;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .method-selector h3 {
            color: #1565c0;
            font-size: 16px;
            margin-bottom: 16px;
            font-weight: 700;
        }
        
        .method-option {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: white;
            border-radius: 8px;
            margin-bottom: 8px;
        }
        
        .method-badge {
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            color: white;
            margin-left: auto;
        }
        
        .badge-fast { background: #ffc107; }
        .badge-accurate { background: #4caf50; }
        .badge-best { background: #9c27b0; }
        
        .neural-status {
            margin-top: 12px;
            padding: 12px;
            background: rgba(33, 150, 243, 0.1);
            border-radius: 8px;
            font-size: 13px;
            color: #1565c0;
        }
        
        .info-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .card {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 20px;
            border-left: 4px solid #667eea;
        }
        
        .card-title {
            font-size: 16px;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 16px;
        }
        
        .progress-ring {
            position: relative;
            width: 120px;
            height: 120px;
            margin: 0 auto 16px;
        }
        
        .progress-ring svg {
            transform: rotate(-90deg);
        }
        
        .progress-ring-circle {
            stroke: #e0e0e0;
            fill: none;
            stroke-width: 8;
        }
        
        .progress-ring-fill {
            stroke: #667eea;
            fill: none;
            stroke-width: 8;
            stroke-linecap: round;
            transition: stroke-dashoffset .5s;
        }
        
        .progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }
        
        .progress-value {
            font-size: 32px;
            font-weight: 700;
            color: #667eea;
        }
        
        .metric-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
        }
        
        .metric-box {
            background: white;
            padding: 16px;
            border-radius: 10px;
            text-align: center;
        }
        
        .metric-value {
            font-size: 28px;
            font-weight: 700;
            color: #667eea;
        }
        
        .metric-label {
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 12px 0;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .stat-row:last-child {
            border-bottom: none;
        }
        
        .test-item {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            background: white;
            border-radius: 8px;
            margin-bottom: 8px;
        }
        
        .test-status {
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
        }
        
        .status-pass {
            background: #d4edda;
            color: #155724;
        }
        
        .status-fail {
            background: #f8d7da;
            color: #721c24;
        }
        
        .status-pending {
            background: #e0e0e0;
            color: #666;
        }
        
        .alert {
            padding: 16px 20px;
            border-radius: 10px;
            font-size: 14px;
            margin-bottom: 10px;
        }
        
        .alert-success {
            background: #d4edda;
            color: #155724;
        }
        
        .alert-error {
            background: #f8d7da;
            color: #721c24;
        }
        
        .alert-warning {
            background: #fff3cd;
            color: #856404;
        }
        
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            color: white;
            flex-direction: column;
            gap: 20px;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #333;
            border-top-color: #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div id="loadingOverlay" class="loading-overlay">
        <div class="spinner"></div>
        <div style="font-size:18px;font-weight:600">Initializing...</div>
        <div style="font-size:14px;opacity:.8" id="loadText">Loading...</div>
    </div>

    <div class="container">
        <div class="header">
            <h1>üõ° Advanced rPPG Liveness Detection</h1>
            <p>Enterprise-Grade Anti-Spoofing System | Two-Input Neural Network | 98.27% AUC</p>
        </div>

        <div class="main-content">
            <div class="video-panel">
                <div class="video-container" id="videoContainer">
                    <video id="webcam" autoplay playsinline muted></video>
                    <canvas id="canvas"></canvas>
                    
                    <div class="status-badge">
                        <span class="status-dot dot-idle" id="statusDot"></span>
                        <span class="status-text" id="statusText">READY</span>
                    </div>
                    
                    <div class="ppg-compact">
                        <div class="ppg-header">
                            <span>BVP: <span id="compactBVP">--</span></span>
                            <span>Samples: <span id="compactSamples">0</span></span>
                        </div>
                        <canvas id="ppgWaveform" class="ppg-waveform"></canvas>
                    </div>
                </div>

                <div class="control-panel">
                    <button id="startBtn" class="btn btn-primary btn-full">üé• Start Camera</button>
                    <button id="analyzeBtn" class="btn btn-success" disabled>üîç Start Analysis</button>
                    <button id="stopBtn" class="btn btn-danger" disabled>‚èπ Stop</button>
                </div>

                <div class="method-selector">
                    <h3>üî¨ Detection Method</h3>
                    <div class="method-option">
                        <input type="radio" id="methodGMM" name="detectionMethod" value="gmm">
                        <label for="methodGMM">GMM Classifier (Fast)</label>
                        <span class="method-badge badge-fast">FAST</span>
                    </div>
                    <div class="method-option">
                        <input type="radio" id="methodNeural" name="detectionMethod" value="neural">
                        <label for="methodNeural">Neural Network (Accurate)</label>
                        <span class="method-badge badge-accurate">98.27% AUC</span>
                    </div>
                    <div class="method-option">
                        <input type="radio" id="methodHybrid" name="detectionMethod" value="hybrid" checked>
                        <label for="methodHybrid">Hybrid Mode (Recommended)</label>
                        <span class="method-badge badge-best">BEST</span>
                    </div>
                    <div class="neural-status" id="neuralStatus">
                        üîÑ Loading neural network...
                    </div>
                </div>

                <div id="alertBox"></div>
            </div>

            <div class="info-panel">
                <div class="card">
                    <div class="card-title">üéØ Liveness Confidence</div>
                    <div class="progress-ring">
                        <svg width="120" height="120">
                            <circle class="progress-ring-circle" cx="60" cy="60" r="52"></circle>
                            <circle id="progressCircle" class="progress-ring-fill" cx="60" cy="60" r="52" 
                                    stroke-dasharray="326.73" stroke-dashoffset="326.73"></circle>
                        </svg>
                        <div class="progress-text">
                            <div class="progress-value" id="confidenceValue">0%</div>
                        </div>
                    </div>
                    <div class="metric-grid">
                        <div class="metric-box">
                            <div class="metric-value" id="gmmScore">--</div>
                            <div class="metric-label">GMM Score</div>
                        </div>
                        <div class="metric-box">
                            <div class="metric-value" id="neuralScore">--</div>
                            <div class="metric-label">Neural Score</div>
                        </div>
                        <div class="metric-box">
                            <div class="metric-value" id="depthScore">--</div>
                            <div class="metric-label">3D Depth</div>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <div class="card-title">üìä Detection Metrics</div>
                    <div class="stat-row">
                        <span>Analysis Time:</span>
                        <span id="duration">0.0s</span>
                    </div>
                    <div class="stat-row">
                        <span>Method:</span>
                        <span id="currentMethod">Hybrid Mode</span>
                    </div>
                    <div class="stat-row">
                        <span>1st Deriv (√ó10‚Åª¬≥):</span>
                        <span id="derivValue">--</span>
                    </div>
                    <div class="stat-row">
                        <span>Embedding:</span>
                        <span id="embeddingConsistency">--</span>
                    </div>
                </div>

                <div class="card">
                    <div class="card-title">üß™ Anti-Spoofing Tests</div>
                    <div class="test-item">
                        <span>‚úì GMM Derivative</span>
                        <span class="test-status status-pending" id="test1">Pending</span>
                    </div>
                    <div class="test-item">
                        <span>‚úì Neural Embedding</span>
                        <span class="test-status status-pending" id="test2">Pending</span>
                    </div>
                    <div class="test-item">
                        <span>‚úì Embedding Consistency</span>
                        <span class="test-status status-pending" id="test3">Pending</span>
                    </div>
                    <div class="test-item">
                        <span>‚úì Temporal Depth</span>
                        <span class="test-status status-pending" id="test4">Pending</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============================================================================
        // CONFIGURATION
        // ============================================================================
        const MODEL_URL = 'https://aero34317-coder.github.io/PPG_tfjs_model/model.json';
        
        const CFG = {
            FPS: 30,
            MIN_SAMPLES: 150,
            NEURAL_SAMPLES: 1024,
            CONFIDENCE_THRESHOLD: 45,
            BANDPASS_LOW: 0.5,
            BANDPASS_HIGH: 8.0,
            GMM_FAKE_THRESHOLD: 1300,
            GMM_REAL_THRESHOLD: 2000,
            DEPTH_TEMPORAL_THRESHOLD: 0.00015,
            EMBEDDING_CONSISTENCY_THRESHOLD: 0.85
        };

        // ============================================================================
        // STATE
        // ============================================================================
        const STATE = {
            faceMesh: null,
            videoStream: null,
            animationFrameId: null,
            isAnalyzing: false,
            startTime: null,
            neuralModel: null,
            neuralModelLoaded: false,
            detectionMethod: 'hybrid',
            rSignal: [],
            gSignal: [],
            bSignal: [],
            posSignal: [],
            depthHistory: [],
            firstDerivVariance: 0,
            embeddings: [],
            embeddingConsistency: 0,
            temporalDepthVariance: 0,
            isStaticDepth: false,
            metricsInterval: null
        };

        // ============================================================================
        // DOM ELEMENTS
        // ============================================================================
        const E = {
            webcam: document.getElementById('webcam'),
            canvas: document.getElementById('canvas'),
            videoContainer: document.getElementById('videoContainer'),
            statusDot: document.getElementById('statusDot'),
            statusText: document.getElementById('statusText'),
            ppgWaveform: document.getElementById('ppgWaveform'),
            compactBVP: document.getElementById('compactBVP'),
            compactSamples: document.getElementById('compactSamples'),
            startBtn: document.getElementById('startBtn'),
            analyzeBtn: document.getElementById('analyzeBtn'),
            stopBtn: document.getElementById('stopBtn'),
            alertBox: document.getElementById('alertBox'),
            confidenceValue: document.getElementById('confidenceValue'),
            progressCircle: document.getElementById('progressCircle'),
            gmmScore: document.getElementById('gmmScore'),
            neuralScore: document.getElementById('neuralScore'),
            depthScore: document.getElementById('depthScore'),
            duration: document.getElementById('duration'),
            derivValue: document.getElementById('derivValue'),
            embeddingConsistency: document.getElementById('embeddingConsistency'),
            currentMethod: document.getElementById('currentMethod'),
            test1: document.getElementById('test1'),
            test2: document.getElementById('test2'),
            test3: document.getElementById('test3'),
            test4: document.getElementById('test4'),
            loadingOverlay: document.getElementById('loadingOverlay'),
            loadText: document.getElementById('loadText'),
            neuralStatus: document.getElementById('neuralStatus')
        };

        // ============================================================================
        // UTILITY FUNCTIONS
        // ============================================================================
        function calculateMean(arr) {
            if (!arr || arr.length === 0) return 0;
            return arr.reduce((sum, val) => sum + val, 0) / arr.length;
        }

        function calculateStd(arr) {
            if (!arr || arr.length === 0) return 0;
            const mean = calculateMean(arr);
            const variance = arr.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / arr.length;
            return Math.sqrt(variance);
        }

        function normalizeSignal(arr) {
            const mean = calculateMean(arr);
            const std = calculateStd(arr);
            if (std === 0) return arr.map(() => 0);
            return arr.map(val => (val - mean) / std);
        }

        function cosineSimilarity(vecA, vecB) {
            if (vecA.length !== vecB.length) return 0;
            let dotProduct = 0, normA = 0, normB = 0;
            for (let i = 0; i < vecA.length; i++) {
                dotProduct += vecA[i] * vecB[i];
                normA += vecA[i] * vecA[i];
                normB += vecB[i] * vecB[i];
            }
            normA = Math.sqrt(normA);
            normB = Math.sqrt(normB);
            return (normA > 0 && normB > 0) ? dotProduct / (normA * normB) : 0;
        }

        // ============================================================================
        // SIGNAL PROCESSING
        // ============================================================================
        function lightBandpassFilter(signal, fps, lowCut, highCut) {
            if (signal.length < 10) return signal;
            const mean = calculateMean(signal);
            let filtered = signal.map(val => val - mean);
            const windowSize = Math.max(3, Math.floor(fps / highCut));
            const smoothed = [];
            for (let i = 0; i < filtered.length; i++) {
                const start = Math.max(0, i - Math.floor(windowSize / 2));
                const end = Math.min(filtered.length, i + Math.ceil(windowSize / 2));
                smoothed.push(calculateMean(filtered.slice(start, end)));
            }
            return smoothed;
        }

        function extractPPG(image, landmarks) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = image.width;
            canvas.height = image.height;
            ctx.drawImage(image, 0, 0);
            
            const regions = [
                [10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288],
                [205, 50, 123, 132, 177, 147, 187, 207, 216, 206],
                [425, 280, 352, 361, 401, 376, 411, 427, 436, 426]
            ];
            
            let totalR = 0, totalG = 0, totalB = 0, pixelCount = 0;
            
            for (const region of regions) {
                for (const idx of region) {
                    const point = landmarks[idx];
                    const x = Math.floor(point.x * canvas.width);
                    const y = Math.floor(point.y * canvas.height);
                    if (x >= 0 && x < canvas.width && y >= 0 && y < canvas.height) {
                        const pixel = ctx.getImageData(x, y, 1, 1).data;
                        totalR += pixel[0];
                        totalG += pixel[1];
                        totalB += pixel[2];
                        pixelCount++;
                    }
                }
            }
            
            if (pixelCount === 0) return { r: 0, g: 0, b: 0 };
            return {
                r: totalR / pixelCount,
                g: totalG / pixelCount,
                b: totalB / pixelCount
            };
        }

        function processPOS() {
            if (STATE.rSignal.length < CFG.MIN_SAMPLES) return null;
            
            const rNorm = normalizeSignal(STATE.rSignal);
            const gNorm = normalizeSignal(STATE.gSignal);
            const bNorm = normalizeSignal(STATE.bSignal);
            
            const posRaw = [];
            for (let i = 0; i < rNorm.length; i++) {
                posRaw.push(3.0 * gNorm[i] - 1.5 * rNorm[i] - 1.5 * bNorm[i]);
            }
            
            STATE.posSignal = lightBandpassFilter(posRaw, CFG.FPS, CFG.BANDPASS_LOW, CFG.BANDPASS_HIGH);
            return STATE.posSignal;
        }

        function analyzeWaveformDerivatives() {
            if (STATE.rSignal.length < 90) return null;
            
            const recentR = STATE.rSignal.slice(-90);
            const recentG = STATE.gSignal.slice(-90);
            const recentB = STATE.bSignal.slice(-90);
            
            const meanR = calculateMean(recentR);
            const meanG = calculateMean(recentG);
            const meanB = calculateMean(recentB);
            
            const normR = recentR.map(v => v - meanR);
            const normG = recentG.map(v => v - meanG);
            const normB = recentB.map(v => v - meanB);
            
            const rawPOS = [];
            for (let i = 0; i < normR.length; i++) {
                rawPOS.push(3.0 * normG[i] - 1.5 * normR[i] - 1.5 * normB[i]);
            }
            
            const firstDeriv = [];
            for (let i = 1; i < rawPOS.length; i++) {
                firstDeriv.push(Math.abs(rawPOS[i] - rawPOS[i - 1]));
            }
            
            STATE.firstDerivVariance = calculateMean(firstDeriv) * 1000;
            return { firstDerivVariance: STATE.firstDerivVariance };
        }

        // ============================================================================
        // MORPHOLOGICAL FEATURES
        // ============================================================================
        function findPeaks(signal) {
            const peaks = [];
            const minDistance = Math.floor(0.4 * CFG.FPS);
            let lastPeak = -minDistance;
            
            for (let i = 1; i < signal.length - 1; i++) {
                if (signal[i] > signal[i-1] && signal[i] > signal[i+1]) {
                    if (i - lastPeak >= minDistance && signal[i] > 0.5) {
                        peaks.push(i);
                        lastPeak = i;
                    }
                }
            }
            return peaks;
        }

        function extractMorphologicalFeatures(signal) {
            const features = new Array(20).fill(0);
            
            try {
                const peaks = findPeaks(signal);
                if (peaks.length < 2) return features;
                
                const ppis = [];
                for (let i = 1; i < peaks.length; i++) {
                    ppis.push((peaks[i] - peaks[i-1]) / CFG.FPS);
                }
                
                if (ppis.length > 0) {
                    features[0] = calculateMean(ppis);
                    features[1] = calculateStd(ppis);
                    features[2] = Math.max(...ppis);
                    features[3] = Math.min(...ppis);
                }
                
                const amplitudes = peaks.map(p => signal[p]);
                features[6] = calculateMean(amplitudes);
                features[7] = calculateStd(amplitudes);
                
                features[15] = calculateMean(signal);
                features[16] = calculateStd(signal);
                features[17] = Math.max(...signal);
                features[18] = Math.min(...signal);
            } catch (error) {
                console.error('Feature extraction error:', error);
            }
            
            return features;
        }

        // ============================================================================
        // NEURAL NETWORK
        // ============================================================================
        async function loadNeuralModel() {
            try {
                E.neuralStatus.textContent = 'üîÑ Loading neural network...';
                E.loadText.textContent = 'Loading two-input model...';
                
                console.log('Loading model from:', MODEL_URL);
                
                // Load the model - NO custom layers needed!
                STATE.neuralModel = await tf.loadLayersModel(MODEL_URL);
                STATE.neuralModelLoaded = true;
                
                console.log('‚úÖ Model loaded successfully!');
                console.log('Inputs:', STATE.neuralModel.inputs.map(i => ({
                    name: i.name, 
                    shape: i.shape
                })));
                console.log('Output:', STATE.neuralModel.outputs[0].shape);
                
                E.neuralStatus.innerHTML = '‚úÖ <strong>Neural model loaded!</strong> 98.27% AUC';
                E.neuralStatus.style.background = 'rgba(76, 175, 80, 0.2)';
                E.neuralStatus.style.color = '#2e7d32';
                
                // Test the model
                console.log('Testing model with dummy data...');
                const testSignal = tf.zeros([1, 1024, 1]);
                const testFeatures = tf.zeros([1, 20, 1]);
                const testOutput = STATE.neuralModel.predict([testSignal, testFeatures]);
                console.log('‚úÖ Test prediction successful! Output shape:', testOutput.shape);
                testSignal.dispose();
                testFeatures.dispose();
                testOutput.dispose();
                
            } catch (error) {
                console.error('‚ùå Error loading neural model:', error);
                E.neuralStatus.innerHTML = '‚ö† <strong>Neural model unavailable.</strong> Using GMM only.';
                E.neuralStatus.style.background = 'rgba(255, 152, 0, 0.2)';
                E.neuralStatus.style.color = '#e65100';
                STATE.neuralModelLoaded = false;
                document.getElementById('methodGMM').checked = true;
                STATE.detectionMethod = 'gmm';
                E.currentMethod.textContent = 'GMM Classifier';
            }
        }

        async function getNeuralEmbedding(signal1024) {
            if (!STATE.neuralModelLoaded || !STATE.neuralModel) {
                return null;
            }
            
            try {
                const morphFeatures = extractMorphologicalFeatures(signal1024);
                
                // Prepare two separate inputs
                const signalTensor = tf.tensor3d([signal1024.map(v => [v])]);      // [1, 1024, 1]
                const featuresTensor = tf.tensor3d([morphFeatures.map(v => [v])]); // [1, 20, 1]
                
                // Predict with TWO inputs
                const embedding = STATE.neuralModel.predict([signalTensor, featuresTensor]);
                const embeddingArray = await embedding.data();
                
                // Clean up
                signalTensor.dispose();
                featuresTensor.dispose();
                embedding.dispose();
                
                return Array.from(embeddingArray);
            } catch (error) {
                console.error('Error in neural embedding:', error);
                return null;
            }
        }

        async function checkEmbeddingConsistency() {
            if (STATE.posSignal.length < CFG.NEURAL_SAMPLES * 2) {
                return { consistency: 0 };
            }
            
            try {
                const window1 = STATE.posSignal.slice(0, CFG.NEURAL_SAMPLES);
                const window2 = STATE.posSignal.slice(
                    Math.floor(CFG.NEURAL_SAMPLES / 2),
                    Math.floor(CFG.NEURAL_SAMPLES / 2) + CFG.NEURAL_SAMPLES
                );
                const window3 = STATE.posSignal.slice(-CFG.NEURAL_SAMPLES);
                
                const emb1 = await getNeuralEmbedding(window1);
                const emb2 = await getNeuralEmbedding(window2);
                const emb3 = await getNeuralEmbedding(window3);
                
                if (!emb1 || !emb2 || !emb3) {
                    return { consistency: 0 };
                }
                
                const sim12 = cosineSimilarity(emb1, emb2);
                const sim23 = cosineSimilarity(emb2, emb3);
                const sim13 = cosineSimilarity(emb1, emb3);
                const consistency = (sim12 + sim23 + sim13) / 3;
                
                console.log(`üß† Embedding Consistency: ${(consistency * 100).toFixed(1)}%`);
                
                return { consistency };
            } catch (error) {
                console.error('Error checking embedding consistency:', error);
                return { consistency: 0 };
            }
        }

        // ============================================================================
        // DEPTH ANALYSIS
        // ============================================================================
        function analyze3DDepth(landmarks) {
            if (!landmarks || landmarks.length < 468) return null;
            
            const noseTip = landmarks[1];
            const leftCheek = landmarks[205];
            const rightCheek = landmarks[425];
            const zValues = [noseTip.z, leftCheek.z, rightCheek.z];
            const zVariance = calculateStd(zValues);
            
            STATE.depthHistory.push(zVariance);
            if (STATE.depthHistory.length > 60) {
                STATE.depthHistory.shift();
            }
            
            return { zVariance };
        }

        function analyzeTemporalDepthVariance() {
            if (STATE.depthHistory.length < 30) return null;
            
            const recentDepth = STATE.depthHistory.slice(-30);
            STATE.temporalDepthVariance = calculateStd(recentDepth);
            STATE.isStaticDepth = STATE.temporalDepthVariance < CFG.DEPTH_TEMPORAL_THRESHOLD;
            
            return { temporalVariance: STATE.temporalDepthVariance };
        }

        // ============================================================================
        // CONFIDENCE CALCULATION
        // ============================================================================
        async function calculateConfidence() {
            const method = STATE.detectionMethod;
            let gmmConf = 0;
            let neuralConf = 0;
            let depthConf = 0;
            
            const firstDeriv = STATE.firstDerivVariance || 0;
            
            if (firstDeriv >= CFG.GMM_REAL_THRESHOLD) {
                gmmConf = 100;
            } else if (firstDeriv > CFG.GMM_FAKE_THRESHOLD) {
                gmmConf = ((firstDeriv - CFG.GMM_FAKE_THRESHOLD) / (CFG.GMM_REAL_THRESHOLD - CFG.GMM_FAKE_THRESHOLD)) * 100;
            } else {
                gmmConf = 10;
            }
            
            if (STATE.neuralModelLoaded && STATE.posSignal.length >= CFG.NEURAL_SAMPLES * 2) {
                const result = await checkEmbeddingConsistency();
                STATE.embeddingConsistency = result.consistency;
                neuralConf = result.consistency * 100;
            }
            
            const temporalDepth = STATE.temporalDepthVariance || 0;
            depthConf = STATE.isStaticDepth ? 20 : Math.min(100, (temporalDepth / CFG.DEPTH_TEMPORAL_THRESHOLD) * 100);
            
            E.gmmScore.textContent = Math.round(gmmConf);
            E.neuralScore.textContent = STATE.neuralModelLoaded ? Math.round(neuralConf) : '--';
            E.depthScore.textContent = Math.round(depthConf);
            E.embeddingConsistency.textContent = STATE.neuralModelLoaded ? 
                `${(STATE.embeddingConsistency * 100).toFixed(1)}%` : '--';
            
            let finalConfidence = 0;
            
            if (method === 'gmm') {
                finalConfidence = gmmConf * 0.7 + depthConf * 0.3;
                updateTest('test1', gmmConf > 50);
                updateTest('test2', null);
                updateTest('test3', null);
            } else if (method === 'neural' && STATE.neuralModelLoaded) {
                finalConfidence = neuralConf * 0.8 + depthConf * 0.2;
                updateTest('test1', null);
                updateTest('test2', neuralConf > 80);
                updateTest('test3', STATE.embeddingConsistency > CFG.EMBEDDING_CONSISTENCY_THRESHOLD);
            } else if (method === 'hybrid') {
                if (gmmConf < 25) {
                    finalConfidence = gmmConf;
                    updateTest('test1', false);
                    updateTest('test2', null);
                    updateTest('test3', null);
                } else if (STATE.neuralModelLoaded && neuralConf > 0) {
                    finalConfidence = neuralConf * 0.6 + gmmConf * 0.3 + depthConf * 0.1;
                    updateTest('test1', gmmConf > 50);
                    updateTest('test2', neuralConf > 70);
                    updateTest('test3', STATE.embeddingConsistency > CFG.EMBEDDING_CONSISTENCY_THRESHOLD);
                } else {
                    finalConfidence = gmmConf * 0.7 + depthConf * 0.3;
                    updateTest('test1', gmmConf > 50);
                    updateTest('test2', null);
                    updateTest('test3', null);
                }
            }
            
            updateTest('test4', depthConf > 50);
            
            return Math.max(0, Math.min(100, finalConfidence));
        }

        // ============================================================================
        // UI FUNCTIONS
        // ============================================================================
        function showAlert(type, message) {
            E.alertBox.innerHTML = `<div class="alert alert-${type}">${message}</div>`;
            setTimeout(() => {
                E.alertBox.innerHTML = '';
            }, 5000);
        }

        function updateStatus(status, text) {
            E.statusDot.className = 'status-dot dot-' + status;
            E.statusText.textContent = text;
        }

        function updateConfidence(value) {
            const percentage = Math.round(value);
            E.confidenceValue.textContent = percentage + '%';
            const circumference = 326.73;
            const offset = circumference - (percentage / 100) * circumference;
            E.progressCircle.style.strokeDashoffset = offset;
        }

        function updateTest(testId, passed) {
            const element = E[testId];
            if (!element) return;
            
            if (passed === null) {
                element.textContent = 'Pending';
                element.className = 'test-status status-pending';
            } else if (passed) {
                element.textContent = 'Pass';
                element.className = 'test-status status-pass';
            } else {
                element.textContent = 'Fail';
                element.className = 'test-status status-fail';
            }
        }

        function drawWaveform() {
            if (!STATE.posSignal || STATE.posSignal.length < 10) return;
            
            const canvas = E.ppgWaveform;
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.clearRect(0, 0, width, height);
            
            const signal = STATE.posSignal.slice(-120);
            const step = width / signal.length;
            const max = Math.max(...signal);
            const min = Math.min(...signal);
            const range = max - min || 1;
            
            ctx.strokeStyle = '#4caf50';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < signal.length; i++) {
                const x = i * step;
                const y = height - ((signal[i] - min) / range) * (height - 10) - 5;
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
        }

        function resetState() {
            Object.assign(STATE, {
                rSignal: [],
                gSignal: [],
                bSignal: [],
                posSignal: [],
                depthHistory: [],
                firstDerivVariance: 0,
                embeddings: [],
                embeddingConsistency: 0,
                temporalDepthVariance: 0,
                isStaticDepth: false
            });
            
            updateConfidence(0);
            E.gmmScore.textContent = '--';
            E.neuralScore.textContent = '--';
            E.depthScore.textContent = '--';
            E.compactBVP.textContent = '--';
            E.compactSamples.textContent = '0';
            E.derivValue.textContent = '--';
            E.embeddingConsistency.textContent = '--';
            
            ['test1', 'test2', 'test3', 'test4'].forEach(id => updateTest(id, null));
        }

        async function updateMetrics() {
            if (!STATE.isAnalyzing) return;
            
            if (STATE.startTime) {
                const elapsed = (Date.now() - STATE.startTime) / 1000;
                E.duration.textContent = elapsed.toFixed(1) + 's';
            }
            
            E.compactSamples.textContent = STATE.rSignal.length;
            
            if (STATE.firstDerivVariance > 0) {
                E.derivValue.textContent = STATE.firstDerivVariance.toFixed(1);
            }
            
            drawWaveform();
            
            const confidence = await calculateConfidence();
            updateConfidence(confidence);
            
            if (STATE.rSignal.length >= CFG.MIN_SAMPLES) {
                if (confidence >= CFG.CONFIDENCE_THRESHOLD) {
                    E.videoContainer.className = 'video-container verified';
                    updateStatus('verified', 'VERIFIED');
                    showAlert('success', '‚úì Real human detected!');
                } else if (confidence < 35) {
                    E.videoContainer.className = 'video-container rejected';
                    updateStatus('rejected', 'REJECTED');
                    showAlert('error', '‚úó Spoofing attempt detected!');
                } else {
                    E.videoContainer.className = 'video-container analyzing';
                    updateStatus('analyzing', 'ANALYZING');
                }
            }
        }

        // ============================================================================
        // FACE MESH PROCESSING
        // ============================================================================
        function onFaceMeshResults(results) {
            if (!STATE.isAnalyzing) return;
            
            const canvasCtx = E.canvas.getContext('2d');
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, E.canvas.width, E.canvas.height);
            
            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                const landmarks = results.multiFaceLandmarks[0];
                
                const rgb = extractPPG(results.image, landmarks);
                STATE.rSignal.push(rgb.r);
                STATE.gSignal.push(rgb.g);
                STATE.bSignal.push(rgb.b);
                
                if (STATE.rSignal.length >= CFG.MIN_SAMPLES) {
                    processPOS();
                    analyzeWaveformDerivatives();
                    analyze3DDepth(landmarks);
                    analyzeTemporalDepthVariance();
                }
                
                // Draw face overlay
                canvasCtx.strokeStyle = 'rgba(76, 175, 80, 0.3)';
                canvasCtx.lineWidth = 1;
                
                const faceOval = [10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288, 
                                  397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136, 
                                  172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109];
                
                canvasCtx.beginPath();
                for (let i = 0; i < faceOval.length; i++) {
                    const point = landmarks[faceOval[i]];
                    const x = point.x * E.canvas.width;
                    const y = point.y * E.canvas.height;
                    if (i === 0) canvasCtx.moveTo(x, y);
                    else canvasCtx.lineTo(x, y);
                }
                canvasCtx.closePath();
                canvasCtx.stroke();
            }
            
            canvasCtx.restore();
        }

        // ============================================================================
        // CAMERA AND ANALYSIS CONTROL
        // ============================================================================
        async function startCamera() {
            try {
                E.loadingOverlay.style.display = 'flex';
                E.loadText.textContent = 'Requesting camera access...';
                
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 1280, height: 720, facingMode: 'user' }
                });
                
                STATE.videoStream = stream;
                E.webcam.srcObject = stream;
                
                E.loadText.textContent = 'Initializing Face Mesh...';
                
                STATE.faceMesh = new FaceMesh({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
                });
                
                STATE.faceMesh.setOptions({
                    maxNumFaces: 1,
                    refineLandmarks: true,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                STATE.faceMesh.onResults(onFaceMeshResults);
                
                await new Promise(resolve => {
                    E.webcam.onloadedmetadata = resolve;
                });
                
                E.canvas.width = E.webcam.videoWidth;
                E.canvas.height = E.webcam.videoHeight;
                
                E.loadingOverlay.style.display = 'none';
                E.startBtn.disabled = true;
                E.analyzeBtn.disabled = false;
                updateStatus('idle', 'READY');
                showAlert('success', 'Camera initialized successfully!');
                
            } catch (error) {
                console.error('Camera error:', error);
                E.loadingOverlay.style.display = 'none';
                showAlert('error', 'Failed to access camera: ' + error.message);
            }
        }

        async function startAnalysis() {
            STATE.isAnalyzing = true;
            STATE.startTime = Date.now();
            resetState();
            
            E.analyzeBtn.disabled = true;
            E.stopBtn.disabled = false;
            E.videoContainer.className = 'video-container analyzing';
            updateStatus('analyzing', 'ANALYZING');
            
            const processFrame = async () => {
                if (!STATE.isAnalyzing) return;
                
                if (E.webcam.readyState === E.webcam.HAVE_ENOUGH_DATA) {
                    await STATE.faceMesh.send({ image: E.webcam });
                }
                
                STATE.animationFrameId = requestAnimationFrame(processFrame);
            };
            
            processFrame();
            STATE.metricsInterval = setInterval(updateMetrics, 200);
            showAlert('warning', 'Analysis started. Please stay still and look at the camera.');
        }

        function stopAnalysis() {
            STATE.isAnalyzing = false;
            
            if (STATE.animationFrameId) {
                cancelAnimationFrame(STATE.animationFrameId);
                STATE.animationFrameId = null;
            }
            
            if (STATE.metricsInterval) {
                clearInterval(STATE.metricsInterval);
                STATE.metricsInterval = null;
            }
            
            if (STATE.videoStream) {
                STATE.videoStream.getTracks().forEach(track => track.stop());
                STATE.videoStream = null;
            }
            
            E.webcam.srcObject = null;
            E.startBtn.disabled = false;
            E.analyzeBtn.disabled = true;
            E.stopBtn.disabled = true;
            E.videoContainer.className = 'video-container';
            updateStatus('idle', 'STOPPED');
            showAlert('warning', 'Analysis stopped.');
        }

        // ============================================================================
        // EVENT LISTENERS
        // ============================================================================
        document.querySelectorAll('input[name="detectionMethod"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                STATE.detectionMethod = e.target.value;
                const methodNames = {
                    'gmm': 'GMM Classifier',
                    'neural': 'Neural Network',
                    'hybrid': 'Hybrid Mode'
                };
                E.currentMethod.textContent = methodNames[STATE.detectionMethod];
                console.log(`üîÑ Switched to: ${methodNames[STATE.detectionMethod]}`);
            });
        });

        E.startBtn.addEventListener('click', startCamera);
        E.analyzeBtn.addEventListener('click', startAnalysis);
        E.stopBtn.addEventListener('click', stopAnalysis);

        // ============================================================================
        // INITIALIZATION
        // ============================================================================
        console.log('üõ° rPPG Liveness Detection System');
        console.log('üìä Two-Input Model: signal[1,1024,1] + features[1,20,1]');
        console.log('üß† Neural Network: 98.27% AUC, 3.89% EER');
        console.log('');
        
        loadNeuralModel();
    </script>
</body>
</html>
                